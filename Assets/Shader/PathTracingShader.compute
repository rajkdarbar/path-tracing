#pragma kernel CSMain

RWTexture2D<float4> Result; // writable texture to store the final rendered image.

float4x4 CameraToWorld;
float4x4 CameraInverseProjection;

float4 DirectionalLight;
float2 PixelOffset;

float Width;
float Height;
float OrthoSize;
float OrthographicMode;

Texture2D<float4> SkyboxTexture;
SamplerState sampler_SkyboxTexture;

static const float PI = 3.14159265f;
static const float EPSILON = 0.00000001f; // same as 1e - 8

float2 pixel;
float seed;

float rand()
{
    float num = dot(pixel, float2(12.9898f, 78.233f));
    float result = frac(sin(seed / 100.0f * num) * 43758.5453f); // take fraction part
    seed += 1.0f;
    return result;
}

float energy(float3 color)
{
    return (color.r + color.g + color.b) / 3.0f;
}

struct Sphere
{
    float3 position;
    float radius;
    float3 albedo;
    float3 specular;
    float smoothness;
    float3 emission;
};

StructuredBuffer<Sphere> SpheresBuffer;

struct Triangle
{
    float3 v0, v1, v2;
    float3 normal;
    float3 albedo;
    float3 specular;
    float smoothness;
    float3 emission;
};

StructuredBuffer<Triangle> TrianglesBuffer;


struct Ray
{
    float3 origin;
    float3 direction;
    float3 energy;
};

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.energy = float3(1.0f, 1.0f, 1.0f);
    return ray;
}


Ray CreateCameraRay(float2 uv, float isOrthographicMode)
{
    if (isOrthographicMode == 1.0f)
    {
        float aspect = (Width / Height);
        float3 originViewSpace = float3(uv.x * aspect * OrthoSize, uv.y * OrthoSize, 0); // map UV to view - space positions on the image plane
        float3 origin = mul(CameraToWorld, float4(originViewSpace, 1)).xyz;
        float3 direction = normalize(mul((float3x3)CameraToWorld, float3(0, 0, - 1))); // all rays have the same forward direction (- Z in view space)

        return CreateRay(origin, direction);
    }

    else
    {

        /*

        // Simple perspective camera
        float3 origin = mul(CameraToWorld, float4(0, 0, 0, 1)).xyz;
        float3 dirView = normalize(float3(uv.x, uv.y, - 1)); // ray through pixel on image plane
        float3 direction = normalize(mul((float3x3)CameraToWorld, dirView));
        return CreateRay(origin, direction);

        */


        // Camera origin in world space
        float3 origin = mul(CameraToWorld, float4(0, 0, 0, 1)).xyz;

        // Unproject from NDC → view space
        float4 pos = mul(CameraInverseProjection, float4(uv, 1.0f, 1.0f));
        pos /= pos.w; // perspective divide
        float3 viewDir = normalize(pos.xyz); // direction in view space

        // Convert to world space
        float3 direction = mul(CameraToWorld, float4(viewDir, 0)).xyz;
        direction = normalize(direction);

        return CreateRay(origin, direction);
    }
}



struct RayHit
{
    float3 position;
    float distance;
    float3 normal;
    float3 albedo;
    float3 specular;
    float smoothness;
    float3 emission;
};

RayHit CreateRayHit()
{
    RayHit hit;
    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.distance = 1.#INF;
    hit.normal = float3(0.0f, 0.0f, 0.0f);
    hit.albedo = float3(0.0f, 0.0f, 0.0f);
    hit.specular = float3(0.0f, 0.0f, 0.0f);
    hit.smoothness = 0.0f;
    hit.emission = float3(0.0f, 0.0f, 0.0f);
    return hit;
}

void IntersectGroundPlane(Ray ray, inout RayHit bestHit)
{
    float denom = ray.direction.y;

    // 1. Only intersect if ray is pointing downward
    // 2. Avoid division by zero and near-zero

    if (denom >= - 0.0001) // if ray is not pointing down enough
    return;

    float t = - ray.origin.y / denom; // ground plane is aligned with XZ plane passing through the origin

    if (t > 0 && t < bestHit.distance)
    {
        bestHit.distance = t;
        bestHit.position = ray.origin + t * ray.direction;
        bestHit.normal = float3(0.0f, 1.0f, 0.0f); // plane normal is along the Y direction

        // The ground plane is a diffuse surface
        bestHit.albedo = float3(0.82, 0.78, 0.72);
        bestHit.specular = float3(0.04f, 0.04f, 0.04f);
        bestHit.smoothness = 0.0f;
        bestHit.emission = float3(0.0f, 0.0f, 0.0f);
    }
}


void IntersectSphere(Ray ray, inout RayHit bestHit, uint sphereIndex)
{
    Sphere sphere = SpheresBuffer[sphereIndex];

    float3 d = ray.origin - sphere.position; // vector from sphere center to ray origin

    // Quadratic coefficients for: t² + bt + c = 0
    float a = 1.0f;
    float b = 2.0f * dot(ray.direction, d);
    float c = dot(d, d) - sphere.radius * sphere.radius;

    float discriminant = b * b - 4.0f * a * c;
    if (discriminant < 0.0f)
    return; // no intersection

    float sqrtDisc = sqrt(discriminant);

    // Find two roots
    float t1 = (- b - sqrtDisc) * 0.5f; // divided by 2a = 2
    float t2 = (- b + sqrtDisc) * 0.5f;

    // Pick nearest positive root
    float t = (t1 > 0.0f) ? t1 : t2;
    if (t <= 0.0f || t >= bestHit.distance)
    return;

    // Update closest hit
    bestHit.distance = t;
    bestHit.position = ray.origin + t * ray.direction;
    bestHit.normal = normalize(bestHit.position - sphere.position);

    bestHit.albedo = sphere.albedo;
    bestHit.specular = sphere.specular;
    bestHit.smoothness = sphere.smoothness;
    bestHit.emission = sphere.emission;
}


// This is Möller–Trumbore ray-triangle intersection algorithm
void IntersectTriangle(Ray ray, inout RayHit bestHit, uint triIndex)
{
    Triangle tri = TrianglesBuffer[triIndex];

    float3 edge1 = tri.v1 - tri.v0;
    float3 edge2 = tri.v2 - tri.v0;

    float3 pvec = cross(ray.direction, edge2);
    float det = dot(edge1, pvec);

    // Reject near-zero determinant
    if (abs(det) < EPSILON) return;

    float invDet = 1.0f / det;
    float3 tvec = ray.origin - tri.v0;

    float u = dot(tvec, pvec) * invDet;
    if (u < 0.0f || u > 1.0f) return;

    float3 qvec = cross(tvec, edge1);
    float v = dot(ray.direction, qvec) * invDet;
    if (v < 0.0f || u + v > 1.0f) return;

    float t = dot(edge2, qvec) * invDet;

    // Ensure the hit is in front of the ray
    if (t <= EPSILON || t >= bestHit.distance)
    return;

    // Optionally flip normal if backface hit (depends on convention)
    float3 normal = normalize(tri.normal);
    if (dot(ray.direction, normal) > 0.0f)
    normal = - normal;

    // Update hit
    bestHit.distance = t;
    bestHit.position = ray.origin + t * ray.direction;
    bestHit.normal = normal;
    bestHit.albedo = tri.albedo;
    bestHit.specular = tri.specular;
    bestHit.smoothness = tri.smoothness;
    bestHit.emission = tri.emission;
}


RayHit Trace(Ray ray)
{
    RayHit bestHit = CreateRayHit();

    // Trace ground plane
    IntersectGroundPlane(ray, bestHit);

    // Trace spheres
    uint numSpheres, strideSphere;
    SpheresBuffer.GetDimensions(numSpheres, strideSphere);

    for (uint i = 0; i < numSpheres; i ++)
    IntersectSphere(ray, bestHit, i);

    // Trace triangles
    uint numTris, strideTriangle;
    TrianglesBuffer.GetDimensions(numTris, strideTriangle);
    for (uint i = 0; i < numTris; i ++)
    IntersectTriangle(ray, bestHit, i);

    return bestHit;
}


float SmoothnessToPhongAlpha(float s)
{
    return pow(1000.0f, s * s);
}

float3 SampleHemispherePhong(float3 R, float alpha)
{
    float r1 = rand();
    float r2 = rand();

    float phi = 2.0f * PI * r1;
    float cosTheta = pow(r2, 1.0f / (alpha + 1.0f));
    float sinTheta = sqrt(1.0f - cosTheta * cosTheta);

    float3 localDir = float3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta); // sampled direction

    // Build TBN matrix (surface normal is +Z axis which is pointing towards the up direction)
    float3 helper = abs(R.z) < 0.999f ? float3(0, 0, 1) : float3(1, 0, 0);
    float3 tangent = normalize(cross(helper, R));
    float3 bitangent = cross(R, tangent);
    float3x3 TBN = float3x3(tangent, bitangent, R);

    // Transform sampled direction from tangent space to world space
    float3 worldDir = mul(localDir, TBN);
    worldDir = normalize(worldDir);
    return worldDir;
}


float3 SampleHemisphereCosine(float3 N)
{
    // Random numbers in [0,1]
    float r1 = rand();
    float r2 = rand();

    // Convert (r1, r2) to spherical cosine-weighted distribution
    float phi = 2.0f * PI * r1;
    float r = sqrt(r2);

    float x = r * cos(phi);
    float y = r * sin(phi);
    float z = sqrt(max(0.0f, 1.0f - r2)); // cos(theta)

    float3 localDir = float3(x, y, z); // sampled direction

    // Build TBN matrix (surface normal is +Z axis which is pointing towards the up direction)
    float3 helper = abs(N.z) < 0.999f ? float3(0, 0, 1) : float3(1, 0, 0);
    float3 tangent = normalize(cross(helper, N));
    float3 bitangent = cross(N, tangent);
    float3x3 TBN = float3x3(tangent, bitangent, N);

    // Transform sampled direction from tangent space to world space
    float3 worldDir = mul(localDir, TBN);
    worldDir = normalize(worldDir);
    return worldDir;
}


float approx(float a, float b, float eps = 0.001f)
{
    return abs(a - b) < eps;
}

bool approx3(float3 a, float3 b, float eps = 0.001f)
{
    return approx(a.x, b.x, eps) && approx(a.y, b.y, eps) && approx(a.z, b.z, eps);
}

float3 Shade(inout Ray ray, RayHit hit)
{
    // Case I: SKY (miss case)
    if (hit.distance == 1.#INF || hit.distance > 1e5)
    {
        ray.energy = 0.0f;

        float theta = acos(ray.direction.y) / - PI;
        float phi = atan2(ray.direction.x, - ray.direction.z) / - PI * 0.5f;
        float3 sky = SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
        return sky * 1.5f;
    }

    float3 emission = hit.emission;

    // Case II: EMISSIVE Sphere acts as a light source
    bool isEmissive = any(hit.emission > 0.0f);
    if (isEmissive)
    {
        ray.energy = 0.0f;
        return emission;
    }

    // Material Classification: DIFFUSE
    bool isDiffuse =
    any(hit.albedo > 0) &&
    approx3(hit.specular, float3(0.04, 0.04, 0.04)) &&
    approx(hit.smoothness, 0.0f);

    // Material Classification: GLOSSY METALLIC
    bool isGlossyMetal =
    length(hit.albedo) < 0.001 &&
    any(hit.specular > 0) &&
    hit.smoothness >= 0.6f;

    // Material Classification: GLOSSY DIELECTRIC
    bool isGlossyDielectric =
    any(hit.albedo > 0) &&
    approx3(hit.specular, float3(1, 1, 1)) &&
    hit.smoothness > 0.0f && hit.smoothness < 0.6f;


    // Case III: DIFFUSE SHADE
    if (isDiffuse)
    {
        // Sampling outgoing ray along the surfce normal direction
        ray.direction = SampleHemisphereCosine(hit.normal);
        ray.origin = hit.position + ray.direction * 0.005f;
        ray.energy *= hit.albedo;
        return 0;
    }

    // Case IV: GLOSSY METALLIC SHADE
    if (isGlossyMetal)
    {
        // 1. Incoming angle
        float cosTheta_i = saturate(dot(hit.normal, - ray.direction));

        // 2. Sample outgoing ray direction from Phong lobe; NOT Blinn-Phong lobe
        float3 R = reflect(ray.direction, hit.normal);
        float alpha = SmoothnessToPhongAlpha(hit.smoothness);
        float3 wo = SampleHemispherePhong(R, alpha);

        // 3. Monte-Carlo weight
        float weight = ((alpha + 2.0f) / (alpha + 1.0f)) * cosTheta_i;

        // 4. Update the outgoing ray
        ray.direction = wo;
        ray.origin = hit.position + wo * 0.005f;
        ray.energy *= hit.specular * weight;
        return 0;
    }

    //Case V: GLOSSY DIELECTRIC SHADE (mixed of diffuse + specular)
    if (isGlossyDielectric)
    {
        // Russian Roulette based selection
        float diffChance = energy(hit.albedo);
        float specChance = energy(hit.specular);
        float sum = diffChance + specChance;

        // Note that, (diffProbability + specProbability) = 1
        float diffProbability = (diffChance / sum);
        float specProbability = (specChance / sum);

        float r = rand();

        if (r < specProbability)
        {
            // SPECULAR branch
            float3 R = reflect(ray.direction, hit.normal);
            float alpha = SmoothnessToPhongAlpha(hit.smoothness);
            float3 wo = SampleHemispherePhong(R, alpha);

            // cos(theta_i) = incoming angle
            float cosTheta_i = saturate(dot(hit.normal, - ray.direction));

            // Monte-Carlo weight for Phong lobe
            float weight = ((alpha + 2.0f) / (alpha + 1.0f)) * cosTheta_i;

            // Update the outgoing ray
            ray.direction = wo;
            ray.origin = hit.position + wo * 0.005f;
            ray.energy *= (hit.specular * (weight / specProbability)); // division by 'specProbability' makes Russian Roulette based selection unbaised
            return 0;
        }

        // DIFFUSE branch
        float3 wo = SampleHemisphereCosine(hit.normal);

        ray.direction = wo;
        ray.origin = hit.position + wo * 0.005f;
        ray.energy *= (hit.albedo / diffProbability); // division by 'diffProbability' makes Russian Roulette based selection unbaised
        return 0;
    }

    return float3(0, 0, 0); // fallback
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    pixel = id.xy;

    // Convert pixel coordinates to normalized device coordinates [-1, 1]
    float2 uv = ((id.xy + PixelOffset) / float2(Width, Height)) * 2.0f - 1.0f;

    // Generate a primary ray from the camera through this pixel
    Ray ray = CreateCameraRay(uv, OrthographicMode);

    float3 shadedColor = float3(0, 0, 0);

    // Trace and shade the ray
    for (int bounce = 0; bounce < 10; bounce ++)
    {
        float3 incidentRayEnergy = ray.energy; // current light intensity carried by the ray

        RayHit hit = Trace(ray); // find intersection with the scene

        float3 reflectedRadiance = Shade(ray, hit); // light reflected / emitted from the surface toward the camera
        shadedColor += incidentRayEnergy * reflectedRadiance; // accumulate final pixel color


        // Russian Roulette: probabilistic early path termination
        float p = max(ray.energy.r, max(ray.energy.g, ray.energy.b));
        p = clamp(p, 0.05f, 0.99f); // keep survival probability within [5 %, 99 % ]

        if (rand() > p)
        break; // terminate the path randomly

        ray.energy /= p; // scale energy to keep the estimator unbiased
    }

    // Store final pixel color
    Result[id.xy] = float4(shadedColor, 1);
}